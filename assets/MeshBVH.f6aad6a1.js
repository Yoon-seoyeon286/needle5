import{d as $n,V as L,n as Y,bD as kn,bM as G,bP as W,f as ut,a as j,y as Hn,s as se,t as ie,F as Sn}from"./three@0.169.11.js";const Xn=0,oe=1,re=2,fs=0,us=1,_n=2,en=1.25,Mn=1,zt=6*4+4+4,jt=65535,ce=Math.pow(2,-24),sn=Symbol("SKIP_GENERATION");function ae(s){return s.index?s.index.count:s.attributes.position.count}function ct(s){return ae(s)/3}function le(s,n=ArrayBuffer){return s>65535?new Uint32Array(new n(4*s)):new Uint16Array(new n(2*s))}function fe(s,n){if(!s.index){const t=s.attributes.position.count,e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=le(t,e);s.setIndex(new $n(o,1));for(let a=0;a<t;a++)o[a]=a}}function Zn(s,n){const t=ct(s),e=n||s.drawRange,o=e.start/3,a=(e.start+e.count)/3,i=Math.max(0,o),c=Math.min(t,a)-i;return[{offset:Math.floor(i),count:Math.floor(c)}]}function Yn(s,n){if(!s.groups||!s.groups.length)return Zn(s,n);const t=[],e=new Set,o=n||s.drawRange,a=o.start/3,i=(o.start+o.count)/3;for(const r of s.groups){const p=r.start/3,f=(r.start+r.count)/3;e.add(Math.max(a,p)),e.add(Math.min(i,f))}const c=Array.from(e.values()).sort((r,p)=>r-p);for(let r=0;r<c.length-1;r++){const p=c[r],f=c[r+1];t.push({offset:Math.floor(p),count:Math.floor(f-p)})}return t}function ue(s,n){const t=ct(s),e=Yn(s,n).sort((i,c)=>i.offset-c.offset),o=e[e.length-1];o.count=Math.min(t-o.offset,o.count);let a=0;return e.forEach(({count:i})=>a+=i),t!==a}function on(s,n,t,e,o){let a=1/0,i=1/0,c=1/0,r=-1/0,p=-1/0,f=-1/0,u=1/0,l=1/0,y=1/0,P=-1/0,B=-1/0,g=-1/0;for(let A=n*6,h=(n+t)*6;A<h;A+=6){const d=s[A+0],x=s[A+1],m=d-x,T=d+x;m<a&&(a=m),T>r&&(r=T),d<u&&(u=d),d>P&&(P=d);const w=s[A+2],M=s[A+3],S=w-M,_=w+M;S<i&&(i=S),_>p&&(p=_),w<l&&(l=w),w>B&&(B=w);const U=s[A+4],b=s[A+5],C=U-b,I=U+b;C<c&&(c=C),I>f&&(f=I),U<y&&(y=U),U>g&&(g=U)}e[0]=a,e[1]=i,e[2]=c,e[3]=r,e[4]=p,e[5]=f,o[0]=u,o[1]=l,o[2]=y,o[3]=P,o[4]=B,o[5]=g}function pe(s,n=null,t=null,e=null){const o=s.attributes.position,a=s.index?s.index.array:null,i=ct(s),c=o.normalized;let r;n===null?r=new Float32Array(i*6):r=n,t=t||0,e=e||i;const p=o.array,f=o.offset||0;let u=3;o.isInterleavedBufferAttribute&&(u=o.data.stride);const l=["getX","getY","getZ"];for(let y=t;y<t+e;y++){const P=y*3,B=y*6;let g=P+0,A=P+1,h=P+2;a&&(g=a[g],A=a[A],h=a[h]),c||(g=g*u+f,A=A*u+f,h=h*u+f);for(let d=0;d<3;d++){let x,m,T;c?(x=o[l[d]](g),m=o[l[d]](A),T=o[l[d]](h)):(x=p[g+d],m=p[A+d],T=p[h+d]);let w=x;m<w&&(w=m),T<w&&(w=T);let M=x;m>M&&(M=m),T>M&&(M=T);const S=(M-w)/2,_=d*2;r[B+_+0]=w+S,r[B+_+1]=S+(Math.abs(w)+S)*ce}}return r}function F(s,n,t){return t.min.x=n[s],t.min.y=n[s+1],t.min.z=n[s+2],t.max.x=n[s+3],t.max.y=n[s+4],t.max.z=n[s+5],t}function Cn(s){let n=-1,t=-1/0;for(let e=0;e<3;e++){const o=s[e+3]-s[e];o>t&&(t=o,n=e)}return n}function Un(s,n){n.set(s)}function In(s,n,t){let e,o;for(let a=0;a<3;a++){const i=a+3;e=s[a],o=n[a],t[a]=e<o?e:o,e=s[i],o=n[i],t[i]=e>o?e:o}}function Dt(s,n,t){for(let e=0;e<3;e++){const o=n[s+2*e],a=n[s+2*e+1],i=o-a,c=o+a;i<t[e]&&(t[e]=i),c>t[e+3]&&(t[e+3]=c)}}function gt(s){const n=s[3]-s[0],t=s[4]-s[1],e=s[5]-s[2];return 2*(n*t+t*e+e*n)}const J=32,ye=(s,n)=>s.candidate-n.candidate,st=new Array(J).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ft=new Float32Array(6);function me(s,n,t,e,o,a){let i=-1,c=0;if(a===Xn)i=Cn(n),i!==-1&&(c=(n[i]+n[i+3])/2);else if(a===oe)i=Cn(s),i!==-1&&(c=de(t,e,o,i));else if(a===re){const r=gt(s);let p=en*o;const f=e*6,u=(e+o)*6;for(let l=0;l<3;l++){const y=n[l],g=(n[l+3]-y)/J;if(o<J/4){const A=[...st];A.length=o;let h=0;for(let x=f;x<u;x+=6,h++){const m=A[h];m.candidate=t[x+2*l],m.count=0;const{bounds:T,leftCacheBounds:w,rightCacheBounds:M}=m;for(let S=0;S<3;S++)M[S]=1/0,M[S+3]=-1/0,w[S]=1/0,w[S+3]=-1/0,T[S]=1/0,T[S+3]=-1/0;Dt(x,t,T)}A.sort(ye);let d=o;for(let x=0;x<d;x++){const m=A[x];for(;x+1<d&&A[x+1].candidate===m.candidate;)A.splice(x+1,1),d--}for(let x=f;x<u;x+=6){const m=t[x+2*l];for(let T=0;T<d;T++){const w=A[T];m>=w.candidate?Dt(x,t,w.rightCacheBounds):(Dt(x,t,w.leftCacheBounds),w.count++)}}for(let x=0;x<d;x++){const m=A[x],T=m.count,w=o-m.count,M=m.leftCacheBounds,S=m.rightCacheBounds;let _=0;T!==0&&(_=gt(M)/r);let U=0;w!==0&&(U=gt(S)/r);const b=Mn+en*(_*T+U*w);b<p&&(i=l,p=b,c=m.candidate)}}else{for(let d=0;d<J;d++){const x=st[d];x.count=0,x.candidate=y+g+d*g;const m=x.bounds;for(let T=0;T<3;T++)m[T]=1/0,m[T+3]=-1/0}for(let d=f;d<u;d+=6){let T=~~((t[d+2*l]-y)/g);T>=J&&(T=J-1);const w=st[T];w.count++,Dt(d,t,w.bounds)}const A=st[J-1];Un(A.bounds,A.rightCacheBounds);for(let d=J-2;d>=0;d--){const x=st[d],m=st[d+1];In(x.bounds,m.rightCacheBounds,x.rightCacheBounds)}let h=0;for(let d=0;d<J-1;d++){const x=st[d],m=x.count,T=x.bounds,M=st[d+1].rightCacheBounds;m!==0&&(h===0?Un(T,Ft):In(T,Ft,Ft)),h+=m;let S=0,_=0;h!==0&&(S=gt(Ft)/r);const U=o-h;U!==0&&(_=gt(M)/r);const b=Mn+en*(S*h+_*U);b<p&&(i=l,p=b,c=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:i,pos:c}}function de(s,n,t,e){let o=0;for(let a=n,i=n+t;a<i;a++)o+=s[a*6+e*2];return o/t}class rn{constructor(){this.boundingData=new Float32Array(6)}}function xe(s,n,t,e,o,a){let i=e,c=e+o-1;const r=a.pos,p=a.axis*2;for(;;){for(;i<=c&&t[i*6+p]<r;)i++;for(;i<=c&&t[c*6+p]>=r;)c--;if(i<c){for(let f=0;f<3;f++){let u=n[i*3+f];n[i*3+f]=n[c*3+f],n[c*3+f]=u}for(let f=0;f<6;f++){let u=t[i*6+f];t[i*6+f]=t[c*6+f],t[c*6+f]=u}i++,c--}else return i}}function he(s,n,t,e,o,a){let i=e,c=e+o-1;const r=a.pos,p=a.axis*2;for(;;){for(;i<=c&&t[i*6+p]<r;)i++;for(;i<=c&&t[c*6+p]>=r;)c--;if(i<c){let f=s[i];s[i]=s[c],s[c]=f;for(let u=0;u<6;u++){let l=t[i*6+u];t[i*6+u]=t[c*6+u],t[c*6+u]=l}i++,c--}else return i}}function R(s,n){return n[s+15]===65535}function q(s,n){return n[s+6]}function k(s,n){return n[s+14]}function H(s){return s+8}function X(s,n){return n[s+6]}function Kn(s,n){return n[s+7]}function ps(s){return s}let Qn,Lt,Qt,Wn;const we=Math.pow(2,32);function yn(s){return"count"in s?1:1+yn(s.left)+yn(s.right)}function Ae(s,n,t){return Qn=new Float32Array(t),Lt=new Uint32Array(t),Qt=new Uint16Array(t),Wn=new Uint8Array(t),mn(s,n)}function mn(s,n){const t=s/4,e=s/2,o="count"in n,a=n.boundingData;for(let i=0;i<6;i++)Qn[t+i]=a[i];if(o)if(n.buffer){const i=n.buffer;Wn.set(new Uint8Array(i),s);for(let c=s,r=s+i.byteLength;c<r;c+=zt){const p=c/2;R(p,Qt)||(Lt[c/4+6]+=t)}return s+i.byteLength}else{const i=n.offset,c=n.count;return Lt[t+6]=i,Qt[e+14]=c,Qt[e+15]=jt,s+zt}else{const i=n.left,c=n.right,r=n.splitAxis;let p;if(p=mn(s+zt,i),p/4>we)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Lt[t+6]=p/4,p=mn(p,c),Lt[t+7]=r,p}}function Te(s,n){const t=(s.index?s.index.count:s.attributes.position.count)/3,e=t>2**16,o=e?4:2,a=n?new SharedArrayBuffer(t*o):new ArrayBuffer(t*o),i=e?new Uint32Array(a):new Uint16Array(a);for(let c=0,r=i.length;c<r;c++)i[c]=c;return i}function ge(s,n,t,e,o){const{maxDepth:a,verbose:i,maxLeafTris:c,strategy:r,onProgress:p,indirect:f}=o,u=s._indirectBuffer,l=s.geometry,y=l.index?l.index.array:null,P=f?he:xe,B=ct(l),g=new Float32Array(6);let A=!1;const h=new rn;return on(n,t,e,h.boundingData,g),x(h,t,e,g),h;function d(m){p&&p(m/B)}function x(m,T,w,M=null,S=0){if(!A&&S>=a&&(A=!0,i&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(l))),w<=c||S>=a)return d(T+w),m.offset=T,m.count=w,m;const _=me(m.boundingData,M,n,T,w,r);if(_.axis===-1)return d(T+w),m.offset=T,m.count=w,m;const U=P(u,y,n,T,w,_);if(U===T||U===T+w)d(T+w),m.offset=T,m.count=w;else{m.splitAxis=_.axis;const b=new rn,C=T,I=U-T;m.left=b,on(n,C,I,b.boundingData,g),x(b,C,I,g,S+1);const z=new rn,E=U,N=w-I;m.right=z,on(n,E,N,z.boundingData,g),x(z,E,N,g,S+1)}return m}}function Pe(s,n){const t=s.geometry;n.indirect&&(s._indirectBuffer=Te(t,n.useSharedArrayBuffer),ue(t,n.range)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),s._indirectBuffer||fe(t,n);const e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=Zn(t,n.range),a=pe(t,null,o[0].offset,o[0].count),i=n.indirect?o:Yn(t,n.range);s._roots=i.map(c=>{const r=ge(s,a,c.offset,c.count,n),p=yn(r),f=new e(zt*p);return Ae(0,r,f),f})}class tt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let e=1/0,o=-1/0;for(let a=0,i=n.length;a<i;a++){const r=n[a][t];e=r<e?r:e,o=r>o?r:o}this.min=e,this.max=o}setFromPoints(n,t){let e=1/0,o=-1/0;for(let a=0,i=t.length;a<i;a++){const c=t[a],r=n.dot(c);e=r<e?r:e,o=r>o?r:o}this.min=e,this.max=o}isSeparated(n){return this.min>n.max||n.min>this.max}}tt.prototype.setFromBox=function(){const s=new L;return function(t,e){const o=e.min,a=e.max;let i=1/0,c=-1/0;for(let r=0;r<=1;r++)for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){s.x=o.x*r+a.x*(1-r),s.y=o.y*p+a.y*(1-p),s.z=o.z*f+a.z*(1-f);const u=t.dot(s);i=Math.min(u,i),c=Math.max(u,c)}this.min=i,this.max=c}}();const Be=function(){const s=new L,n=new L,t=new L;return function(o,a,i){const c=o.start,r=s,p=a.start,f=n;t.subVectors(c,p),s.subVectors(o.end,o.start),n.subVectors(a.end,a.start);const u=t.dot(f),l=f.dot(r),y=f.dot(f),P=t.dot(r),g=r.dot(r)*y-l*l;let A,h;g!==0?A=(u*l-P*y)/g:A=0,h=(u+A*l)/y,i.x=A,i.y=h}}(),Pn=function(){const s=new Y,n=new L,t=new L;return function(o,a,i,c){Be(o,a,s);let r=s.x,p=s.y;if(r>=0&&r<=1&&p>=0&&p<=1){o.at(r,i),a.at(p,c);return}else if(r>=0&&r<=1){p<0?a.at(0,c):a.at(1,c),o.closestPointToPoint(c,!0,i);return}else if(p>=0&&p<=1){r<0?o.at(0,i):o.at(1,i),a.closestPointToPoint(i,!0,c);return}else{let f;r<0?f=o.start:f=o.end;let u;p<0?u=a.start:u=a.end;const l=n,y=t;if(o.closestPointToPoint(u,!0,n),a.closestPointToPoint(f,!0,t),l.distanceToSquared(u)<=y.distanceToSquared(f)){i.copy(l),c.copy(u);return}else{i.copy(f),c.copy(y);return}}}}(),be=function(){const s=new L,n=new L,t=new kn,e=new G;return function(a,i){const{radius:c,center:r}=a,{a:p,b:f,c:u}=i;if(e.start=p,e.end=f,e.closestPointToPoint(r,!0,s).distanceTo(r)<=c||(e.start=p,e.end=u,e.closestPointToPoint(r,!0,s).distanceTo(r)<=c)||(e.start=f,e.end=u,e.closestPointToPoint(r,!0,s).distanceTo(r)<=c))return!0;const B=i.getPlane(t);if(Math.abs(B.distanceToPoint(r))<=c){const A=B.projectPoint(r,n);if(i.containsPoint(A))return!0}return!1}}(),Se=["x","y","z"],O=1e-15,Ln=O*O;function $(s){return Math.abs(s)<O}class Q extends W{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new tt),this.points=[this.a,this.b,this.c],this.plane=new kn,this.isDegenerateIntoSegment=!1,this.isDegenerateIntoPoint=!1,this.degenerateSegment=new G,this.needsUpdate=!0}intersectsSphere(n){return be(n,this)}update(){const n=this.a,t=this.b,e=this.c,o=this.points,a=this.satAxes,i=this.satBounds,c=a[0],r=i[0];this.getNormal(c),r.setFromPoints(c,o);const p=a[1],f=i[1];p.subVectors(n,t),f.setFromPoints(p,o);const u=a[2],l=i[2];u.subVectors(t,e),l.setFromPoints(u,o);const y=a[3],P=i[3];y.subVectors(e,n),P.setFromPoints(y,o);const B=p.length(),g=u.length(),A=y.length();this.isDegenerateIntoPoint=!1,this.isDegenerateIntoSegment=!1,B<O?g<O||A<O?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(n),this.degenerateSegment.end.copy(e)):g<O?A<O?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(t),this.degenerateSegment.end.copy(n)):A<O&&(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(e),this.degenerateSegment.end.copy(t)),this.plane.setFromNormalAndCoplanarPoint(c,n),this.needsUpdate=!1}}Q.prototype.closestPointToSegment=function(){const s=new L,n=new L,t=new G;return function(o,a=null,i=null){const{start:c,end:r}=o,p=this.points;let f,u=1/0;for(let l=0;l<3;l++){const y=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[y]),Pn(t,o,s,n),f=s.distanceToSquared(n),f<u&&(u=f,a&&a.copy(s),i&&i.copy(n))}return this.closestPointToPoint(c,s),f=c.distanceToSquared(s),f<u&&(u=f,a&&a.copy(s),i&&i.copy(c)),this.closestPointToPoint(r,s),f=r.distanceToSquared(s),f<u&&(u=f,a&&a.copy(s),i&&i.copy(r)),Math.sqrt(u)}}();Q.prototype.intersectsTriangle=function(){const s=new Q,n=new tt,t=new tt,e=new L,o=new L,a=new L,i=new L,c=new G,r=new G,p=new L,f=new Y,u=new Y;function l(d,x,m,T){const w=e;!d.isDegenerateIntoPoint&&!d.isDegenerateIntoSegment?w.copy(d.plane.normal):w.copy(x.plane.normal);const M=d.satBounds,S=d.satAxes;for(let b=1;b<4;b++){const C=M[b],I=S[b];if(n.setFromPoints(I,x.points),C.isSeparated(n)||(i.copy(w).cross(I),n.setFromPoints(i,d.points),t.setFromPoints(i,x.points),n.isSeparated(t)))return!1}const _=x.satBounds,U=x.satAxes;for(let b=1;b<4;b++){const C=_[b],I=U[b];if(n.setFromPoints(I,d.points),C.isSeparated(n)||(i.crossVectors(w,I),n.setFromPoints(i,d.points),t.setFromPoints(i,x.points),n.isSeparated(t)))return!1}return m&&(T||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}function y(d,x,m,T,w,M,S,_,U,b,C){let I=S/(S-_);b.x=T+(w-T)*I,C.start.subVectors(x,d).multiplyScalar(I).add(d),I=S/(S-U),b.y=T+(M-T)*I,C.end.subVectors(m,d).multiplyScalar(I).add(d)}function P(d,x,m,T,w,M,S,_,U,b,C){if(w>0)y(d.c,d.a,d.b,T,x,m,U,S,_,b,C);else if(M>0)y(d.b,d.a,d.c,m,x,T,_,S,U,b,C);else if(_*U>0||S!=0)y(d.a,d.b,d.c,x,m,T,S,_,U,b,C);else if(_!=0)y(d.b,d.a,d.c,m,x,T,_,S,U,b,C);else if(U!=0)y(d.c,d.a,d.b,T,x,m,U,S,_,b,C);else return!0;return!1}function B(d,x,m,T){const w=x.degenerateSegment,M=d.plane.distanceToPoint(w.start),S=d.plane.distanceToPoint(w.end);return $(M)?$(S)?l(d,x,m,T):(m&&(m.start.copy(w.start),m.end.copy(w.start)),d.containsPoint(w.start)):$(S)?(m&&(m.start.copy(w.end),m.end.copy(w.end)),d.containsPoint(w.end)):d.plane.intersectLine(w,e)!=null?(m&&(m.start.copy(e),m.end.copy(e)),d.containsPoint(e)):!1}function g(d,x,m){const T=x.a;return $(d.plane.distanceToPoint(T))&&d.containsPoint(T)?(m&&(m.start.copy(T),m.end.copy(T)),!0):!1}function A(d,x,m){const T=d.degenerateSegment,w=x.a;return T.closestPointToPoint(w,!0,e),w.distanceToSquared(e)<Ln?(m&&(m.start.copy(w),m.end.copy(w)),!0):!1}function h(d,x,m,T){if(d.isDegenerateIntoSegment)if(x.isDegenerateIntoSegment){const w=d.degenerateSegment,M=x.degenerateSegment,S=o,_=a;w.delta(S),M.delta(_);const U=e.subVectors(M.start,w.start),b=S.x*_.y-S.y*_.x;if($(b))return!1;const C=(U.x*_.y-U.y*_.x)/b,I=-(S.x*U.y-S.y*U.x)/b;if(C<0||C>1||I<0||I>1)return!1;const z=w.start.z+S.z*C,E=M.start.z+_.z*I;return $(z-E)?(m&&(m.start.copy(w.start).addScaledVector(S,C),m.end.copy(w.start).addScaledVector(S,C)),!0):!1}else return x.isDegenerateIntoPoint?A(d,x,m):B(x,d,m,T);else{if(d.isDegenerateIntoPoint)return x.isDegenerateIntoPoint?x.a.distanceToSquared(d.a)<Ln?(m&&(m.start.copy(d.a),m.end.copy(d.a)),!0):!1:x.isDegenerateIntoSegment?A(x,d,m):g(x,d,m);if(x.isDegenerateIntoPoint)return g(d,x,m);if(x.isDegenerateIntoSegment)return B(d,x,m,T)}}return function(x,m=null,T=!1){this.needsUpdate&&this.update(),x.isExtendedTriangle?x.needsUpdate&&x.update():(s.copy(x),s.update(),x=s);const w=h(this,x,m,T);if(w!==void 0)return w;const M=this.plane,S=x.plane;let _=S.distanceToPoint(this.a),U=S.distanceToPoint(this.b),b=S.distanceToPoint(this.c);$(_)&&(_=0),$(U)&&(U=0),$(b)&&(b=0);const C=_*U,I=_*b;if(C>0&&I>0)return!1;let z=M.distanceToPoint(x.a),E=M.distanceToPoint(x.b),N=M.distanceToPoint(x.c);$(z)&&(z=0),$(E)&&(E=0),$(N)&&(N=0);const nt=z*E,et=z*N;if(nt>0&&et>0)return!1;o.copy(M.normal),a.copy(S.normal);const Ot=o.cross(a);let Gt=0,tn=Math.abs(Ot.x);const bn=Math.abs(Ot.y);bn>tn&&(tn=bn,Gt=1),Math.abs(Ot.z)>tn&&(Gt=2);const pt=Se[Gt],Jn=this.a[pt],On=this.b[pt],Gn=this.c[pt],te=x.a[pt],ne=x.b[pt],ee=x.c[pt];if(P(this,Jn,On,Gn,C,I,_,U,b,f,c))return l(this,x,m,T);if(P(x,te,ne,ee,nt,et,z,E,N,u,r))return l(this,x,m,T);if(f.y<f.x){const nn=f.y;f.y=f.x,f.x=nn,p.copy(c.start),c.start.copy(c.end),c.end.copy(p)}if(u.y<u.x){const nn=u.y;u.y=u.x,u.x=nn,p.copy(r.start),r.start.copy(r.end),r.end.copy(p)}return f.y<u.x||u.y<f.x?!1:(m&&(u.x>f.x?m.start.copy(r.start):m.start.copy(c.start),u.y<f.y?m.end.copy(r.end):m.end.copy(c.end)),!0)}}();Q.prototype.distanceToPoint=function(){const s=new L;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();Q.prototype.distanceToTriangle=function(){const s=new L,n=new L,t=["a","b","c"],e=new G,o=new G;return function(i,c=null,r=null){const p=c||r?e:null;if(this.intersectsTriangle(i,p))return(c||r)&&(c&&p.getCenter(c),r&&p.getCenter(r)),0;let f=1/0;for(let u=0;u<3;u++){let l;const y=t[u],P=i[y];this.closestPointToPoint(P,s),l=P.distanceToSquared(s),l<f&&(f=l,c&&c.copy(s),r&&r.copy(P));const B=this[y];i.closestPointToPoint(B,s),l=B.distanceToSquared(s),l<f&&(f=l,c&&c.copy(B),r&&r.copy(s))}for(let u=0;u<3;u++){const l=t[u],y=t[(u+1)%3];e.set(this[l],this[y]);for(let P=0;P<3;P++){const B=t[P],g=t[(P+1)%3];o.set(i[B],i[g]),Pn(e,o,s,n);const A=s.distanceToSquared(n);A<f&&(f=A,c&&c.copy(s),r&&r.copy(n))}}return Math.sqrt(f)}}();class V{constructor(n,t,e){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new ut,this.invMatrix=new ut,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new tt),this.alignedSatBounds=new Array(3).fill().map(()=>new tt),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),e&&this.matrix.copy(e)}set(n,t,e){this.min.copy(n),this.max.copy(t),this.matrix.copy(e),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}V.prototype.update=function(){return function(){const n=this.matrix,t=this.min,e=this.max,o=this.points;for(let p=0;p<=1;p++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const l=1*p|2*f|4*u,y=o[l];y.x=p?e.x:t.x,y.y=f?e.y:t.y,y.z=u?e.z:t.z,y.applyMatrix4(n)}const a=this.satBounds,i=this.satAxes,c=o[0];for(let p=0;p<3;p++){const f=i[p],u=a[p],l=1<<p,y=o[l];f.subVectors(c,y),u.setFromPoints(f,o)}const r=this.alignedSatBounds;r[0].setFromPointsField(o,"x"),r[1].setFromPointsField(o,"y"),r[2].setFromPointsField(o,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();V.prototype.intersectsBox=function(){const s=new tt;return function(t){this.needsUpdate&&this.update();const e=t.min,o=t.max,a=this.satBounds,i=this.satAxes,c=this.alignedSatBounds;if(s.min=e.x,s.max=o.x,c[0].isSeparated(s)||(s.min=e.y,s.max=o.y,c[1].isSeparated(s))||(s.min=e.z,s.max=o.z,c[2].isSeparated(s)))return!1;for(let r=0;r<3;r++){const p=i[r],f=a[r];if(s.setFromBox(p,t),f.isSeparated(s))return!1}return!0}}();V.prototype.intersectsTriangle=function(){const s=new Q,n=new Array(3),t=new tt,e=new tt,o=new L;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(s.copy(i),s.update(),i=s);const c=this.satBounds,r=this.satAxes;n[0]=i.a,n[1]=i.b,n[2]=i.c;for(let l=0;l<3;l++){const y=c[l],P=r[l];if(t.setFromPoints(P,n),y.isSeparated(t))return!1}const p=i.satBounds,f=i.satAxes,u=this.points;for(let l=0;l<3;l++){const y=p[l],P=f[l];if(t.setFromPoints(P,u),y.isSeparated(t))return!1}for(let l=0;l<3;l++){const y=r[l];for(let P=0;P<4;P++){const B=f[P];if(o.crossVectors(y,B),t.setFromPoints(o,n),e.setFromPoints(o,u),t.isSeparated(e))return!1}}return!0}}();V.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();V.prototype.distanceToPoint=function(){const s=new L;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();V.prototype.distanceToBox=function(){const s=["x","y","z"],n=new Array(12).fill().map(()=>new G),t=new Array(12).fill().map(()=>new G),e=new L,o=new L;return function(i,c=0,r=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(r||p)&&(i.getCenter(o),this.closestPointToPoint(o,e),i.closestPointToPoint(e,o),r&&r.copy(e),p&&p.copy(o)),0;const f=c*c,u=i.min,l=i.max,y=this.points;let P=1/0;for(let g=0;g<8;g++){const A=y[g];o.copy(A).clamp(u,l);const h=A.distanceToSquared(o);if(h<P&&(P=h,r&&r.copy(A),p&&p.copy(o),h<f))return Math.sqrt(h)}let B=0;for(let g=0;g<3;g++)for(let A=0;A<=1;A++)for(let h=0;h<=1;h++){const d=(g+1)%3,x=(g+2)%3,m=A<<d|h<<x,T=1<<g|A<<d|h<<x,w=y[m],M=y[T];n[B].set(w,M);const _=s[g],U=s[d],b=s[x],C=t[B],I=C.start,z=C.end;I[_]=u[_],I[U]=A?u[U]:l[U],I[b]=h?u[b]:l[U],z[_]=l[_],z[U]=A?u[U]:l[U],z[b]=h?u[b]:l[U],B++}for(let g=0;g<=1;g++)for(let A=0;A<=1;A++)for(let h=0;h<=1;h++){o.x=g?l.x:u.x,o.y=A?l.y:u.y,o.z=h?l.z:u.z,this.closestPointToPoint(o,e);const d=o.distanceToSquared(e);if(d<P&&(P=d,r&&r.copy(e),p&&p.copy(o),d<f))return Math.sqrt(d)}for(let g=0;g<12;g++){const A=n[g];for(let h=0;h<12;h++){const d=t[h];Pn(A,d,e,o);const x=e.distanceToSquared(o);if(x<P&&(P=x,r&&r.copy(e),p&&p.copy(o),x<f))return Math.sqrt(x)}}return Math.sqrt(P)}}();class Bn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class _e extends Bn{constructor(){super(()=>new Q)}}const Z=new _e;class Me{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=e=>{t&&n.push(t),t=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const D=new Me;let ot,Tt;const yt=[],vt=new Bn(()=>new j);function Ce(s,n,t,e,o,a){ot=vt.getPrimitive(),Tt=vt.getPrimitive(),yt.push(ot,Tt),D.setBuffer(s._roots[n]);const i=dn(0,s.geometry,t,e,o,a);D.clearBuffer(),vt.releasePrimitive(ot),vt.releasePrimitive(Tt),yt.pop(),yt.pop();const c=yt.length;return c>0&&(Tt=yt[c-1],ot=yt[c-2]),i}function dn(s,n,t,e,o=null,a=0,i=0){const{float32Array:c,uint16Array:r,uint32Array:p}=D;let f=s*2;if(R(f,r)){const l=q(s,p),y=k(f,r);return F(s,c,ot),e(l,y,!1,i,a+s,ot)}else{let _=function(b){const{uint16Array:C,uint32Array:I}=D;let z=b*2;for(;!R(z,C);)b=H(b),z=b*2;return q(b,I)},U=function(b){const{uint16Array:C,uint32Array:I}=D;let z=b*2;for(;!R(z,C);)b=X(b,I),z=b*2;return q(b,I)+k(z,C)};const l=H(s),y=X(s,p);let P=l,B=y,g,A,h,d;if(o&&(h=ot,d=Tt,F(P,c,h),F(B,c,d),g=o(h),A=o(d),A<g)){P=y,B=l;const b=g;g=A,A=b,h=d}h||(h=ot,F(P,c,h));const x=R(P*2,r),m=t(h,x,g,i+1,a+P);let T;if(m===_n){const b=_(P),I=U(P)-b;T=e(b,I,!0,i+1,a+P,h)}else T=m&&dn(P,n,t,e,o,a,i+1);if(T)return!0;d=Tt,F(B,c,d);const w=R(B*2,r),M=t(d,w,A,i+1,a+B);let S;if(M===_n){const b=_(B),I=U(B)-b;S=e(b,I,!0,i+1,a+B,d)}else S=M&&dn(B,n,t,e,o,a,i+1);return!!S}}const Pt=new L,cn=new L;function Ue(s,n,t={},e=0,o=1/0){const a=e*e,i=o*o;let c=1/0,r=null;if(s.shapecast({boundsTraverseOrder:f=>(Pt.copy(n).clamp(f.min,f.max),Pt.distanceToSquared(n)),intersectsBounds:(f,u,l)=>l<c&&l<i,intersectsTriangle:(f,u)=>{f.closestPointToPoint(n,Pt);const l=n.distanceToSquared(Pt);return l<c&&(cn.copy(Pt),c=l,r=u),l<a}}),c===1/0)return null;const p=Math.sqrt(c);return t.point?t.point.copy(cn):t.point=cn.clone(),t.distance=p,t.faceIndex=r,t}const Vt=parseInt(Hn)>=169,Ie=parseInt(Hn)<=161,at=new L,lt=new L,ft=new L,Rt=new Y,Nt=new Y,qt=new Y,zn=new L,En=new L,Dn=new L,Bt=new L;function Le(s,n,t,e,o,a,i,c){let r;if(a===se?r=s.intersectTriangle(e,t,n,!0,o):r=s.intersectTriangle(n,t,e,a!==ie,o),r===null)return null;const p=s.origin.distanceTo(o);return p<i||p>c?null:{distance:p,point:o.clone()}}function ze(s,n,t,e,o,a,i,c,r,p,f){at.fromBufferAttribute(n,a),lt.fromBufferAttribute(n,i),ft.fromBufferAttribute(n,c);const u=Le(s,at,lt,ft,Bt,r,p,f);if(u){if(e){Rt.fromBufferAttribute(e,a),Nt.fromBufferAttribute(e,i),qt.fromBufferAttribute(e,c),u.uv=new Y;const y=W.getInterpolation(Bt,at,lt,ft,Rt,Nt,qt,u.uv);Vt||(u.uv=y)}if(o){Rt.fromBufferAttribute(o,a),Nt.fromBufferAttribute(o,i),qt.fromBufferAttribute(o,c),u.uv1=new Y;const y=W.getInterpolation(Bt,at,lt,ft,Rt,Nt,qt,u.uv1);Vt||(u.uv1=y),Ie&&(u.uv2=u.uv1)}if(t){zn.fromBufferAttribute(t,a),En.fromBufferAttribute(t,i),Dn.fromBufferAttribute(t,c),u.normal=new L;const y=W.getInterpolation(Bt,at,lt,ft,zn,En,Dn,u.normal);u.normal.dot(s.direction)>0&&u.normal.multiplyScalar(-1),Vt||(u.normal=y)}const l={a,b:i,c,normal:new L,materialIndex:0};if(W.getNormal(at,lt,ft,l.normal),u.face=l,u.faceIndex=a,Vt){const y=new L;W.getBarycoord(Bt,at,lt,ft,y),u.barycoord=y}}return u}function Jt(s,n,t,e,o,a,i){const c=e*3;let r=c+0,p=c+1,f=c+2;const u=s.index;s.index&&(r=u.getX(r),p=u.getX(p),f=u.getX(f));const{position:l,normal:y,uv:P,uv1:B}=s.attributes,g=ze(t,l,y,P,B,r,p,f,n,a,i);return g?(g.faceIndex=e,o&&o.push(g),g):null}function v(s,n,t,e){const o=s.a,a=s.b,i=s.c;let c=n,r=n+1,p=n+2;t&&(c=t.getX(c),r=t.getX(r),p=t.getX(p)),o.x=e.getX(c),o.y=e.getY(c),o.z=e.getZ(c),a.x=e.getX(r),a.y=e.getY(r),a.z=e.getZ(r),i.x=e.getX(p),i.y=e.getY(p),i.z=e.getZ(p)}const bt=new L,St=new L,_t=new L,Fn=new Y,vn=new Y,Vn=new Y;function ys(s,n,t,e){const o=n.getIndex().array,a=n.getAttribute("position"),i=n.getAttribute("uv"),c=o[t*3],r=o[t*3+1],p=o[t*3+2];bt.fromBufferAttribute(a,c),St.fromBufferAttribute(a,r),_t.fromBufferAttribute(a,p);let f=0;const u=n.groups,l=t*3;for(let B=0,g=u.length;B<g;B++){const A=u[B],{start:h,count:d}=A;if(l>=h&&l<h+d){f=A.materialIndex;break}}const y=e&&e.barycoord?e.barycoord:new L;W.getBarycoord(s,bt,St,_t,y);let P=null;return i&&(Fn.fromBufferAttribute(i,c),vn.fromBufferAttribute(i,r),Vn.fromBufferAttribute(i,p),e&&e.uv?P=e.uv:P=new Y,W.getInterpolation(s,bt,St,_t,Fn,vn,Vn,P)),e?(e.face||(e.face={}),e.face.a=c,e.face.b=r,e.face.c=p,e.face.materialIndex=f,e.face.normal||(e.face.normal=new L),W.getNormal(bt,St,_t,e.face.normal),P&&(e.uv=P),e.barycoord=y,e):{face:{a:c,b:r,c:p,materialIndex:f,normal:W.getNormal(bt,St,_t,new L)},uv:P,barycoord:y}}function Ee(s,n,t,e,o,a,i,c){const{geometry:r,_indirectBuffer:p}=s;for(let f=e,u=e+o;f<u;f++)Jt(r,n,t,f,a,i,c)}function De(s,n,t,e,o,a,i){const{geometry:c,_indirectBuffer:r}=s;let p=1/0,f=null;for(let u=e,l=e+o;u<l;u++){let y;y=Jt(c,n,t,u,null,a,i),y&&y.distance<p&&(f=y,p=y.distance)}return f}function Fe(s,n,t,e,o,a,i){const{geometry:c}=t,{index:r}=c,p=c.attributes.position;for(let f=s,u=n+s;f<u;f++){let l;if(l=f,v(i,l*3,r,p),i.needsUpdate=!0,e(i,l,o,a))return!0}return!1}function ve(s,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=s.geometry,e=t.index?t.index.array:null,o=t.attributes.position;let a,i,c,r,p=0;const f=s._roots;for(let l=0,y=f.length;l<y;l++)a=f[l],i=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,y,P=!1){const B=l*2;if(c[B+15]===jt){const A=i[l+6],h=c[B+14];let d=1/0,x=1/0,m=1/0,T=-1/0,w=-1/0,M=-1/0;for(let S=3*A,_=3*(A+h);S<_;S++){let U=e[S];const b=o.getX(U),C=o.getY(U),I=o.getZ(U);b<d&&(d=b),b>T&&(T=b),C<x&&(x=C),C>w&&(w=C),I<m&&(m=I),I>M&&(M=I)}return r[l+0]!==d||r[l+1]!==x||r[l+2]!==m||r[l+3]!==T||r[l+4]!==w||r[l+5]!==M?(r[l+0]=d,r[l+1]=x,r[l+2]=m,r[l+3]=T,r[l+4]=w,r[l+5]=M,!0):!1}else{const A=l+8,h=i[l+6],d=A+y,x=h+y;let m=P,T=!1,w=!1;n?m||(T=n.has(d),w=n.has(x),m=!T&&!w):(T=!0,w=!0);const M=m||T,S=m||w;let _=!1;M&&(_=u(A,y,m));let U=!1;S&&(U=u(h,y,m));const b=_||U;if(b)for(let C=0;C<3;C++){const I=A+C,z=h+C,E=r[I],N=r[I+3],nt=r[z],et=r[z+3];r[l+C]=E<nt?E:nt,r[l+C+3]=N>et?N:et}return b}}}function rt(s,n,t,e,o){let a,i,c,r,p,f;const u=1/t.direction.x,l=1/t.direction.y,y=1/t.direction.z,P=t.origin.x,B=t.origin.y,g=t.origin.z;let A=n[s],h=n[s+3],d=n[s+1],x=n[s+3+1],m=n[s+2],T=n[s+3+2];return u>=0?(a=(A-P)*u,i=(h-P)*u):(a=(h-P)*u,i=(A-P)*u),l>=0?(c=(d-B)*l,r=(x-B)*l):(c=(x-B)*l,r=(d-B)*l),a>r||c>i||((c>a||isNaN(a))&&(a=c),(r<i||isNaN(i))&&(i=r),y>=0?(p=(m-g)*y,f=(T-g)*y):(p=(T-g)*y,f=(m-g)*y),a>f||p>i)?!1:((p>a||a!==a)&&(a=p),(f<i||i!==i)&&(i=f),a<=o&&i>=e)}function Ve(s,n,t,e,o,a,i,c){const{geometry:r,_indirectBuffer:p}=s;for(let f=e,u=e+o;f<u;f++){let l=p?p[f]:f;Jt(r,n,t,l,a,i,c)}}function Re(s,n,t,e,o,a,i){const{geometry:c,_indirectBuffer:r}=s;let p=1/0,f=null;for(let u=e,l=e+o;u<l;u++){let y;y=Jt(c,n,t,r?r[u]:u,null,a,i),y&&y.distance<p&&(f=y,p=y.distance)}return f}function Ne(s,n,t,e,o,a,i){const{geometry:c}=t,{index:r}=c,p=c.attributes.position;for(let f=s,u=n+s;f<u;f++){let l;if(l=t.resolveTriangleIndex(f),v(i,l*3,r,p),i.needsUpdate=!0,e(i,l,o,a))return!0}return!1}function qe(s,n,t,e,o,a,i){D.setBuffer(s._roots[n]),xn(0,s,t,e,o,a,i),D.clearBuffer()}function xn(s,n,t,e,o,a,i){const{float32Array:c,uint16Array:r,uint32Array:p}=D,f=s*2;if(R(f,r)){const l=q(s,p),y=k(f,r);Ee(n,t,e,l,y,o,a,i)}else{const l=H(s);rt(l,c,e,a,i)&&xn(l,n,t,e,o,a,i);const y=X(s,p);rt(y,c,e,a,i)&&xn(y,n,t,e,o,a,i)}}const $e=["x","y","z"];function ke(s,n,t,e,o,a){D.setBuffer(s._roots[n]);const i=hn(0,s,t,e,o,a);return D.clearBuffer(),i}function hn(s,n,t,e,o,a){const{float32Array:i,uint16Array:c,uint32Array:r}=D;let p=s*2;if(R(p,c)){const u=q(s,r),l=k(p,c);return De(n,t,e,u,l,o,a)}else{const u=Kn(s,r),l=$e[u],P=e.direction[l]>=0;let B,g;P?(B=H(s),g=X(s,r)):(B=X(s,r),g=H(s));const h=rt(B,i,e,o,a)?hn(B,n,t,e,o,a):null;if(h){const m=h.point[l];if(P?m<=i[g+u]:m>=i[g+u+3])return h}const x=rt(g,i,e,o,a)?hn(g,n,t,e,o,a):null;return h&&x?h.distance<=x.distance?h:x:h||x||null}}const $t=new j,mt=new Q,dt=new Q,Mt=new ut,Rn=new V,kt=new V;function He(s,n,t,e){D.setBuffer(s._roots[n]);const o=wn(0,s,t,e);return D.clearBuffer(),o}function wn(s,n,t,e,o=null){const{float32Array:a,uint16Array:i,uint32Array:c}=D;let r=s*2;if(o===null&&(t.boundingBox||t.computeBoundingBox(),Rn.set(t.boundingBox.min,t.boundingBox.max,e),o=Rn),R(r,i)){const f=n.geometry,u=f.index,l=f.attributes.position,y=t.index,P=t.attributes.position,B=q(s,c),g=k(r,i);if(Mt.copy(e).invert(),t.boundsTree)return F(s,a,kt),kt.matrix.copy(Mt),kt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:h=>kt.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let d=B*3,x=(g+B)*3;d<x;d+=3)if(v(dt,d,u,l),dt.needsUpdate=!0,h.intersectsTriangle(dt))return!0;return!1}});{const A=ct(t);for(let h=B*3,d=(g+B)*3;h<d;h+=3){v(mt,h,u,l),mt.a.applyMatrix4(Mt),mt.b.applyMatrix4(Mt),mt.c.applyMatrix4(Mt),mt.needsUpdate=!0;for(let x=0,m=A*3;x<m;x+=3)if(v(dt,x,y,P),dt.needsUpdate=!0,mt.intersectsTriangle(dt))return!0}}}else{const f=s+8,u=c[s+6];return F(f,a,$t),!!(o.intersectsBox($t)&&wn(f,n,t,e,o)||(F(u,a,$t),o.intersectsBox($t)&&wn(u,n,t,e,o)))}}const Ht=new ut,an=new V,Ct=new V,Xe=new L,Ze=new L,Ye=new L,Ke=new L;function Qe(s,n,t,e={},o={},a=0,i=1/0){n.boundingBox||n.computeBoundingBox(),an.set(n.boundingBox.min,n.boundingBox.max,t),an.needsUpdate=!0;const c=s.geometry,r=c.attributes.position,p=c.index,f=n.attributes.position,u=n.index,l=Z.getPrimitive(),y=Z.getPrimitive();let P=Xe,B=Ze,g=null,A=null;o&&(g=Ye,A=Ke);let h=1/0,d=null,x=null;return Ht.copy(t).invert(),Ct.matrix.copy(Ht),s.shapecast({boundsTraverseOrder:m=>an.distanceToBox(m),intersectsBounds:(m,T,w)=>w<h&&w<i?(T&&(Ct.min.copy(m.min),Ct.max.copy(m.max),Ct.needsUpdate=!0),!0):!1,intersectsRange:(m,T)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:M=>Ct.distanceToBox(M),intersectsBounds:(M,S,_)=>_<h&&_<i,intersectsRange:(M,S)=>{for(let _=M,U=M+S;_<U;_++){v(y,3*_,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let b=m,C=m+T;b<C;b++){v(l,3*b,p,r),l.needsUpdate=!0;const I=l.distanceToTriangle(y,P,g);if(I<h&&(B.copy(P),A&&A.copy(g),h=I,d=b,x=_),I<a)return!0}}}});{const w=ct(n);for(let M=0,S=w;M<S;M++){v(y,3*M,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let _=m,U=m+T;_<U;_++){v(l,3*_,p,r),l.needsUpdate=!0;const b=l.distanceToTriangle(y,P,g);if(b<h&&(B.copy(P),A&&A.copy(g),h=b,d=_,x=M),b<a)return!0}}}}}),Z.releasePrimitive(l),Z.releasePrimitive(y),h===1/0?null:(e.point?e.point.copy(B):e.point=B.clone(),e.distance=h,e.faceIndex=d,o&&(o.point?o.point.copy(A):o.point=A.clone(),o.point.applyMatrix4(Ht),B.applyMatrix4(Ht),o.distance=B.sub(o.point).length(),o.faceIndex=x),e)}function We(s,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=s.geometry,e=t.index?t.index.array:null,o=t.attributes.position;let a,i,c,r,p=0;const f=s._roots;for(let l=0,y=f.length;l<y;l++)a=f[l],i=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,y,P=!1){const B=l*2;if(c[B+15]===jt){const A=i[l+6],h=c[B+14];let d=1/0,x=1/0,m=1/0,T=-1/0,w=-1/0,M=-1/0;for(let S=A,_=A+h;S<_;S++){const U=3*s.resolveTriangleIndex(S);for(let b=0;b<3;b++){let C=U+b;C=e?e[C]:C;const I=o.getX(C),z=o.getY(C),E=o.getZ(C);I<d&&(d=I),I>T&&(T=I),z<x&&(x=z),z>w&&(w=z),E<m&&(m=E),E>M&&(M=E)}}return r[l+0]!==d||r[l+1]!==x||r[l+2]!==m||r[l+3]!==T||r[l+4]!==w||r[l+5]!==M?(r[l+0]=d,r[l+1]=x,r[l+2]=m,r[l+3]=T,r[l+4]=w,r[l+5]=M,!0):!1}else{const A=l+8,h=i[l+6],d=A+y,x=h+y;let m=P,T=!1,w=!1;n?m||(T=n.has(d),w=n.has(x),m=!T&&!w):(T=!0,w=!0);const M=m||T,S=m||w;let _=!1;M&&(_=u(A,y,m));let U=!1;S&&(U=u(h,y,m));const b=_||U;if(b)for(let C=0;C<3;C++){const I=A+C,z=h+C,E=r[I],N=r[I+3],nt=r[z],et=r[z+3];r[l+C]=E<nt?E:nt,r[l+C+3]=N>et?N:et}return b}}}function je(s,n,t,e,o,a,i){D.setBuffer(s._roots[n]),An(0,s,t,e,o,a,i),D.clearBuffer()}function An(s,n,t,e,o,a,i){const{float32Array:c,uint16Array:r,uint32Array:p}=D,f=s*2;if(R(f,r)){const l=q(s,p),y=k(f,r);Ve(n,t,e,l,y,o,a,i)}else{const l=H(s);rt(l,c,e,a,i)&&An(l,n,t,e,o,a,i);const y=X(s,p);rt(y,c,e,a,i)&&An(y,n,t,e,o,a,i)}}const Je=["x","y","z"];function Oe(s,n,t,e,o,a){D.setBuffer(s._roots[n]);const i=Tn(0,s,t,e,o,a);return D.clearBuffer(),i}function Tn(s,n,t,e,o,a){const{float32Array:i,uint16Array:c,uint32Array:r}=D;let p=s*2;if(R(p,c)){const u=q(s,r),l=k(p,c);return Re(n,t,e,u,l,o,a)}else{const u=Kn(s,r),l=Je[u],P=e.direction[l]>=0;let B,g;P?(B=H(s),g=X(s,r)):(B=X(s,r),g=H(s));const h=rt(B,i,e,o,a)?Tn(B,n,t,e,o,a):null;if(h){const m=h.point[l];if(P?m<=i[g+u]:m>=i[g+u+3])return h}const x=rt(g,i,e,o,a)?Tn(g,n,t,e,o,a):null;return h&&x?h.distance<=x.distance?h:x:h||x||null}}const Xt=new j,xt=new Q,ht=new Q,Ut=new ut,Nn=new V,Zt=new V;function Ge(s,n,t,e){D.setBuffer(s._roots[n]);const o=gn(0,s,t,e);return D.clearBuffer(),o}function gn(s,n,t,e,o=null){const{float32Array:a,uint16Array:i,uint32Array:c}=D;let r=s*2;if(o===null&&(t.boundingBox||t.computeBoundingBox(),Nn.set(t.boundingBox.min,t.boundingBox.max,e),o=Nn),R(r,i)){const f=n.geometry,u=f.index,l=f.attributes.position,y=t.index,P=t.attributes.position,B=q(s,c),g=k(r,i);if(Ut.copy(e).invert(),t.boundsTree)return F(s,a,Zt),Zt.matrix.copy(Ut),Zt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:h=>Zt.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let d=B,x=g+B;d<x;d++)if(v(ht,3*n.resolveTriangleIndex(d),u,l),ht.needsUpdate=!0,h.intersectsTriangle(ht))return!0;return!1}});{const A=ct(t);for(let h=B,d=g+B;h<d;h++){const x=n.resolveTriangleIndex(h);v(xt,3*x,u,l),xt.a.applyMatrix4(Ut),xt.b.applyMatrix4(Ut),xt.c.applyMatrix4(Ut),xt.needsUpdate=!0;for(let m=0,T=A*3;m<T;m+=3)if(v(ht,m,y,P),ht.needsUpdate=!0,xt.intersectsTriangle(ht))return!0}}}else{const f=s+8,u=c[s+6];return F(f,a,Xt),!!(o.intersectsBox(Xt)&&gn(f,n,t,e,o)||(F(u,a,Xt),o.intersectsBox(Xt)&&gn(u,n,t,e,o)))}}const Yt=new ut,ln=new V,It=new V,ts=new L,ns=new L,es=new L,ss=new L;function is(s,n,t,e={},o={},a=0,i=1/0){n.boundingBox||n.computeBoundingBox(),ln.set(n.boundingBox.min,n.boundingBox.max,t),ln.needsUpdate=!0;const c=s.geometry,r=c.attributes.position,p=c.index,f=n.attributes.position,u=n.index,l=Z.getPrimitive(),y=Z.getPrimitive();let P=ts,B=ns,g=null,A=null;o&&(g=es,A=ss);let h=1/0,d=null,x=null;return Yt.copy(t).invert(),It.matrix.copy(Yt),s.shapecast({boundsTraverseOrder:m=>ln.distanceToBox(m),intersectsBounds:(m,T,w)=>w<h&&w<i?(T&&(It.min.copy(m.min),It.max.copy(m.max),It.needsUpdate=!0),!0):!1,intersectsRange:(m,T)=>{if(n.boundsTree){const w=n.boundsTree;return w.shapecast({boundsTraverseOrder:M=>It.distanceToBox(M),intersectsBounds:(M,S,_)=>_<h&&_<i,intersectsRange:(M,S)=>{for(let _=M,U=M+S;_<U;_++){const b=w.resolveTriangleIndex(_);v(y,3*b,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let C=m,I=m+T;C<I;C++){const z=s.resolveTriangleIndex(C);v(l,3*z,p,r),l.needsUpdate=!0;const E=l.distanceToTriangle(y,P,g);if(E<h&&(B.copy(P),A&&A.copy(g),h=E,d=C,x=_),E<a)return!0}}}})}else{const w=ct(n);for(let M=0,S=w;M<S;M++){v(y,3*M,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let _=m,U=m+T;_<U;_++){const b=s.resolveTriangleIndex(_);v(l,3*b,p,r),l.needsUpdate=!0;const C=l.distanceToTriangle(y,P,g);if(C<h&&(B.copy(P),A&&A.copy(g),h=C,d=_,x=M),C<a)return!0}}}}}),Z.releasePrimitive(l),Z.releasePrimitive(y),h===1/0?null:(e.point?e.point.copy(B):e.point=B.clone(),e.distance=h,e.faceIndex=d,o&&(o.point?o.point.copy(A):o.point=A.clone(),o.point.applyMatrix4(Yt),B.applyMatrix4(Yt),o.distance=B.sub(o.point).length(),o.faceIndex=x),e)}function os(){return typeof SharedArrayBuffer<"u"}const Et=new D.constructor,Wt=new D.constructor,it=new Bn(()=>new j),wt=new j,At=new j,fn=new j,un=new j;let pn=!1;function rs(s,n,t,e){if(pn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");pn=!0;const o=s._roots,a=n._roots;let i,c=0,r=0;const p=new ut().copy(t).invert();for(let f=0,u=o.length;f<u;f++){Et.setBuffer(o[f]),r=0;const l=it.getPrimitive();F(0,Et.float32Array,l),l.applyMatrix4(p);for(let y=0,P=a.length;y<P&&(Wt.setBuffer(a[y]),i=K(0,0,t,p,e,c,r,0,0,l),Wt.clearBuffer(),r+=a[y].length,!i);y++);if(it.releasePrimitive(l),Et.clearBuffer(),c+=o[f].length,i)break}return pn=!1,i}function K(s,n,t,e,o,a=0,i=0,c=0,r=0,p=null,f=!1){let u,l;f?(u=Wt,l=Et):(u=Et,l=Wt);const y=u.float32Array,P=u.uint32Array,B=u.uint16Array,g=l.float32Array,A=l.uint32Array,h=l.uint16Array,d=s*2,x=n*2,m=R(d,B),T=R(x,h);let w=!1;if(T&&m)f?w=o(q(n,A),k(n*2,h),q(s,P),k(s*2,B),r,i+n,c,a+s):w=o(q(s,P),k(s*2,B),q(n,A),k(n*2,h),c,a+s,r,i+n);else if(T){const M=it.getPrimitive();F(n,g,M),M.applyMatrix4(t);const S=H(s),_=X(s,P);F(S,y,wt),F(_,y,At);const U=M.intersectsBox(wt),b=M.intersectsBox(At);w=U&&K(n,S,e,t,o,i,a,r,c+1,M,!f)||b&&K(n,_,e,t,o,i,a,r,c+1,M,!f),it.releasePrimitive(M)}else{const M=H(n),S=X(n,A);F(M,g,fn),F(S,g,un);const _=p.intersectsBox(fn),U=p.intersectsBox(un);if(_&&U)w=K(s,M,t,e,o,a,i,c,r+1,p,f)||K(s,S,t,e,o,a,i,c,r+1,p,f);else if(_)if(m)w=K(s,M,t,e,o,a,i,c,r+1,p,f);else{const b=it.getPrimitive();b.copy(fn).applyMatrix4(t);const C=H(s),I=X(s,P);F(C,y,wt),F(I,y,At);const z=b.intersectsBox(wt),E=b.intersectsBox(At);w=z&&K(M,C,e,t,o,i,a,r,c+1,b,!f)||E&&K(M,I,e,t,o,i,a,r,c+1,b,!f),it.releasePrimitive(b)}else if(U)if(m)w=K(s,S,t,e,o,a,i,c,r+1,p,f);else{const b=it.getPrimitive();b.copy(un).applyMatrix4(t);const C=H(s),I=X(s,P);F(C,y,wt),F(I,y,At);const z=b.intersectsBox(wt),E=b.intersectsBox(At);w=z&&K(S,C,e,t,o,i,a,r,c+1,b,!f)||E&&K(S,I,e,t,o,i,a,r,c+1,b,!f),it.releasePrimitive(b)}}return w}const Kt=new V,qn=new j,cs={strategy:Xn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class jn{static serialize(n,t={}){t={cloneBuffers:!0,...t};const e=n.geometry,o=n._roots,a=n._indirectBuffer,i=e.getIndex();let c;return t.cloneBuffers?c={roots:o.map(r=>r.slice()),index:i?i.array.slice():null,indirectBuffer:a?a.slice():null}:c={roots:o,index:i?i.array:null,indirectBuffer:a},c}static deserialize(n,t,e={}){e={setIndex:!0,indirect:!!n.indirectBuffer,...e};const{index:o,roots:a,indirectBuffer:i}=n,c=new jn(t,{...e,[sn]:!0});if(c._roots=a,c._indirectBuffer=i||null,e.setIndex){const r=t.getIndex();if(r===null){const p=new $n(n.index,1,!1);t.setIndex(p)}else r.array!==o&&(r.array.set(o),r.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...cs,[sn]:!1},t),t.useSharedArrayBuffer&&!os())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[sn]||(Pe(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new j))),this.resolveTriangleIndex=t.indirect?e=>this._indirectBuffer[e]:e=>e}refit(n=null){return(this.indirect?We:ve)(this,n)}traverse(n,t=0){const e=this._roots[t],o=new Uint32Array(e),a=new Uint16Array(e);i(0);function i(c,r=0){const p=c*2,f=a[p+15]===jt;if(f){const u=o[c+6],l=a[p+14];n(r,f,new Float32Array(e,c*4,6),u,l)}else{const u=c+zt/4,l=o[c+6],y=o[c+7];n(r,f,new Float32Array(e,c*4,6),y)||(i(u,r+1),i(l,r+1))}}}raycast(n,t=Sn,e=0,o=1/0){const a=this._roots,i=this.geometry,c=[],r=t.isMaterial,p=Array.isArray(t),f=i.groups,u=r?t.side:t,l=this.indirect?je:qe;for(let y=0,P=a.length;y<P;y++){const B=p?t[f[y].materialIndex].side:u,g=c.length;if(l(this,y,B,n,c,e,o),p){const A=f[y].materialIndex;for(let h=g,d=c.length;h<d;h++)c[h].face.materialIndex=A}}return c}raycastFirst(n,t=Sn,e=0,o=1/0){const a=this._roots,i=this.geometry,c=t.isMaterial,r=Array.isArray(t);let p=null;const f=i.groups,u=c?t.side:t,l=this.indirect?Oe:ke;for(let y=0,P=a.length;y<P;y++){const B=r?t[f[y].materialIndex].side:u,g=l(this,y,B,n,e,o);g!=null&&(p==null||g.distance<p.distance)&&(p=g,r&&(g.face.materialIndex=f[y].materialIndex))}return p}intersectsGeometry(n,t){let e=!1;const o=this._roots,a=this.indirect?Ge:He;for(let i=0,c=o.length;i<c&&(e=a(this,i,n,t),!e);i++);return e}shapecast(n){const t=Z.getPrimitive(),e=this.indirect?Ne:Fe;let{boundsTraverseOrder:o,intersectsBounds:a,intersectsRange:i,intersectsTriangle:c}=n;if(i&&c){const u=i;i=(l,y,P,B,g)=>u(l,y,P,B,g)?!0:e(l,y,this,c,P,B,t)}else i||(c?i=(u,l,y,P)=>e(u,l,this,c,y,P,t):i=(u,l,y)=>y);let r=!1,p=0;const f=this._roots;for(let u=0,l=f.length;u<l;u++){const y=f[u];if(r=Ce(this,u,a,i,o,p),r)break;p+=y.byteLength}return Z.releasePrimitive(t),r}bvhcast(n,t,e){let{intersectsRanges:o,intersectsTriangles:a}=e;const i=Z.getPrimitive(),c=this.geometry.index,r=this.geometry.attributes.position,p=this.indirect?P=>{const B=this.resolveTriangleIndex(P);v(i,B*3,c,r)}:P=>{v(i,P*3,c,r)},f=Z.getPrimitive(),u=n.geometry.index,l=n.geometry.attributes.position,y=n.indirect?P=>{const B=n.resolveTriangleIndex(P);v(f,B*3,u,l)}:P=>{v(f,P*3,u,l)};if(a){const P=(B,g,A,h,d,x,m,T)=>{for(let w=A,M=A+h;w<M;w++){y(w),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let S=B,_=B+g;S<_;S++)if(p(S),i.needsUpdate=!0,a(i,f,S,w,d,x,m,T))return!0}return!1};if(o){const B=o;o=function(g,A,h,d,x,m,T,w){return B(g,A,h,d,x,m,T,w)?!0:P(g,A,h,d,x,m,T,w)}}else o=P}return rs(this,n,t,o)}intersectsBox(n,t){return Kt.set(n.min,n.max,t),Kt.needsUpdate=!0,this.shapecast({intersectsBounds:e=>Kt.intersectsBox(e),intersectsTriangle:e=>Kt.intersectsTriangle(e)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,e={},o={},a=0,i=1/0){return(this.indirect?is:Qe)(this,n,t,e,o,a,i)}closestPointToPoint(n,t={},e=0,o=1/0){return Ue(this,n,t,e,o)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(e=>{F(0,new Float32Array(e),qn),n.union(qn)}),n}}export{oe as A,zt as B,k as C,Q as E,R as I,jn as M,fs as N,q as O,X as R,Kn as S,en as T,F as a,Mn as b,ae as c,ps as d,Xn as e,re as f,le as g,us as h,os as i,_n as j,ys as k,V as l};
